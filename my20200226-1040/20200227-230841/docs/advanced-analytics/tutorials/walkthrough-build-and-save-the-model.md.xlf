<?xml version="1.0"?><xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd"><file datatype="xml" original="walkthrough-build-and-save-the-model.md" source-language="en-US" target-language="en-US"><header><tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-0c45fb3" tool-company="Microsoft" /><xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">9e8b99b7-5dd1-4f94-ba72-fb306822a13c4cb806c0a6286ec8a6608b346d12e666a8e9a09f.skl</xliffext:skl_file_name><xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version><xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">4cb806c0a6286ec8a6608b346d12e666a8e9a09f</xliffext:ms.openlocfilehash><xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">9e8b99b7-5dd1-4f94-ba72-fb306822a13c</xliffext:ms.sourcegitcommit><xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02/27/2020</xliffext:ms.lasthandoff><xliffext:ms.openlocfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">docs\advanced-analytics\tutorials\walkthrough-build-and-save-the-model.md</xliffext:ms.openlocfilepath></header><body><group id="content" extype="content"><trans-unit id="101" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>R tutorial: Build and save model</source>
        </trans-unit><trans-unit id="102" translate="yes" xml:space="preserve" restype="x-metadata">
          <source>Tutorial showing how to build an R language model used for SQL Server in-database analytics.</source>
        </trans-unit><trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Build an R model and save to SQL Server (walkthrough)</source>
        </trans-unit><trans-unit id="104" translate="yes" xml:space="preserve">
          <source>In this step, learn how to build a machine learning model and save the model in <ph id="ph1">[!INCLUDE[ssNoVersion](../../includes/ssnoversion-md.md)]</ph>.</source>
        </trans-unit><trans-unit id="105" translate="yes" xml:space="preserve">
          <source>By saving a model, you can call it directly from <ph id="ph1">[!INCLUDE[tsql](../../includes/tsql-md.md)]</ph> code, using the system stored procedure, <bpt id="p1">[</bpt>sp_execute_external_script<ept id="p1">](../../relational-databases/system-stored-procedures/sp-execute-external-script-transact-sql.md)</ept> or the <bpt id="p2">[</bpt>PREDICT (T-SQL) function<ept id="p2">](https://docs.microsoft.com/sql/t-sql/queries/predict-transact-sql)</ept>.</source>
        </trans-unit><trans-unit id="106" translate="yes" xml:space="preserve">
          <source>Prerequisites</source>
        </trans-unit><trans-unit id="107" translate="yes" xml:space="preserve">
          <source>This step assumes an ongoing R session based on previous steps in this walkthrough.</source>
        </trans-unit><trans-unit id="108" translate="yes" xml:space="preserve">
          <source>It uses the connection strings and data source objects created in those steps.</source>
        </trans-unit><trans-unit id="109" translate="yes" xml:space="preserve">
          <source>The following tools and packages are used to run the script.</source>
        </trans-unit><trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Rgui.exe to run R commands</source>
        </trans-unit><trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Management Studio to run T-SQL</source>
        </trans-unit><trans-unit id="112" translate="yes" xml:space="preserve">
          <source>ROCR package</source>
        </trans-unit><trans-unit id="113" translate="yes" xml:space="preserve">
          <source>RODBC package</source>
        </trans-unit><trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Create a stored procedure to save models</source>
        </trans-unit><trans-unit id="115" translate="yes" xml:space="preserve">
          <source>This step uses a stored procedure to save a trained model to SQL Server.</source>
        </trans-unit><trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Creating a stored procedure to perform this operation makes the task easier.</source>
        </trans-unit><trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Run the following T-SQL code in a query windows in Management Studio to create the stored procedure.</source>
        </trans-unit><trans-unit id="118" translate="yes" xml:space="preserve">
          <source>If you get an error, make sure that your login has permission to create objects.</source>
        </trans-unit><trans-unit id="119" translate="yes" xml:space="preserve">
          <source>You can grant explicit permissions to create objects by running a T-SQL statement like this: <ph id="ph1">`exec sp_addrolemember 'db_owner', '&lt;user_name&gt;'`</ph>.</source>
        </trans-unit><trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Create a classification model using rxLogit</source>
        </trans-unit><trans-unit id="121" translate="yes" xml:space="preserve">
          <source>The model is a binary classifier that predicts whether the taxi driver is likely to get a tip on a particular ride or not.</source>
        </trans-unit><trans-unit id="122" translate="yes" xml:space="preserve">
          <source>You'll use the data source you created in the previous lesson to train the tip classifier, using logistic regression.</source>
        </trans-unit><trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Call the <bpt id="p1">[</bpt>rxLogit<ept id="p1">](https://docs.microsoft.com/r-server/r-reference/revoscaler/rxlogit)</ept> function, included in the <bpt id="p2">**</bpt>RevoScaleR<ept id="p2">**</ept> package, to create a logistic regression model.</source>
        </trans-unit><trans-unit id="124" translate="yes" xml:space="preserve">
          <source>The call that builds the model is enclosed in the system.time function.</source>
        </trans-unit><trans-unit id="125" translate="yes" xml:space="preserve">
          <source>This lets you get the time required to build the model.</source>
        </trans-unit><trans-unit id="126" translate="yes" xml:space="preserve">
          <source>After you build the model, you can inspect it using the <ph id="ph1">`summary`</ph> function, and view the coefficients.</source>
        </trans-unit><trans-unit id="127" translate="yes" xml:space="preserve">
          <source><bpt id="p1">**</bpt>Results<ept id="p1">**</ept></source>
        </trans-unit><trans-unit id="128" translate="yes" xml:space="preserve">
          <source>Use the logistic regression model for scoring</source>
        </trans-unit><trans-unit id="129" translate="yes" xml:space="preserve">
          <source>Now that the model is built, you can use to predict whether the driver is likely to get a tip on a particular drive or not.</source>
        </trans-unit><trans-unit id="130" translate="yes" xml:space="preserve">
          <source>First, use the <bpt id="p1">[</bpt>RxSqlServerData<ept id="p1">](https://docs.microsoft.com/r-server/r-reference/revoscaler/rxsqlserverdata)</ept> function to define a data source object for storing the scoring result.</source>
        </trans-unit><trans-unit id="131" translate="yes" xml:space="preserve">
          <source>To make this example simpler, the input to the logistic regression model is the same feature data source (<ph id="ph1">`sql_feature_ds`</ph>) that you used to train the model.</source>
        </trans-unit><trans-unit id="132" translate="yes" xml:space="preserve">
          <source>More typically, you might have some new data to score with, or you might have set aside some data for testing vs. training.</source>
        </trans-unit><trans-unit id="133" translate="yes" xml:space="preserve">
          <source>The prediction results will be saved in the table, <bpt id="p1">_</bpt>taxiscoreOutput<ept id="p1">_</ept>.</source>
        </trans-unit><trans-unit id="134" translate="yes" xml:space="preserve">
          <source>Notice that the schema for this table is not defined when you create it using rxSqlServerData.</source>
        </trans-unit><trans-unit id="135" translate="yes" xml:space="preserve">
          <source>The schema is obtained from the rxPredict output.</source>
        </trans-unit><trans-unit id="136" translate="yes" xml:space="preserve">
          <source>To create the table that stores the predicted values, the SQL login running the rxSqlServer data function must have DDL privileges in the database.</source>
        </trans-unit><trans-unit id="137" translate="yes" xml:space="preserve">
          <source>If the login cannot create tables, the statement fails.</source>
        </trans-unit><trans-unit id="138" translate="yes" xml:space="preserve">
          <source>Call the <bpt id="p1">[</bpt>rxPredict<ept id="p1">](https://docs.microsoft.com/r-server/r-reference/revoscaler/rxpredict)</ept> function to generate results.</source>
        </trans-unit><trans-unit id="139" translate="yes" xml:space="preserve">
          <source>If the statement succeeds, it should take some time to run.</source>
        </trans-unit><trans-unit id="140" translate="yes" xml:space="preserve">
          <source>When complete, you can open SQL Server Management Studio and verify that the table was created and that it contains the Score column and other expected output.</source>
        </trans-unit><trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Plot model accuracy</source>
        </trans-unit><trans-unit id="142" translate="yes" xml:space="preserve">
          <source>To get an idea of the accuracy of the model, you can use the <bpt id="p1">[</bpt>rxRoc<ept id="p1">](https://docs.microsoft.com/r-server/r-reference/revoscaler/rxroc)</ept> function to plot the Receiver Operating Curve.</source>
        </trans-unit><trans-unit id="143" translate="yes" xml:space="preserve">
          <source>Because rxRoc is one of the new functions provided by the RevoScaleR package that supports remote compute contexts, you have two options:</source>
        </trans-unit><trans-unit id="144" translate="yes" xml:space="preserve">
          <source>You can use the rxRoc function to execute the plot in the remote compute context and then return the plot to your local client.</source>
        </trans-unit><trans-unit id="145" translate="yes" xml:space="preserve">
          <source>You can also import the data to your R client computer, and use other R plotting functions to create the performance graph.</source>
        </trans-unit><trans-unit id="146" translate="yes" xml:space="preserve">
          <source>In this section, you'll experiment with both techniques.</source>
        </trans-unit><trans-unit id="147" translate="yes" xml:space="preserve">
          <source>Execute a plot in the remote (SQL Server) compute context</source>
        </trans-unit><trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Call the function rxRoc and provide the data defined earlier as input.</source>
        </trans-unit><trans-unit id="149" translate="yes" xml:space="preserve">
          <source>This call returns the values used in computing the ROC chart.</source>
        </trans-unit><trans-unit id="150" translate="yes" xml:space="preserve">
          <source>The label column is <bpt id="p1">_</bpt>tipped<ept id="p1">_</ept>, which has the actual results you are trying to predict, while the <bpt id="p2">_</bpt>Score<ept id="p2">_</ept> column has the prediction.</source>
        </trans-unit><trans-unit id="151" translate="yes" xml:space="preserve">
          <source>To actually plot the chart, you can save the ROC object and then draw it with the plot function.</source>
        </trans-unit><trans-unit id="152" translate="yes" xml:space="preserve">
          <source>The graph is created on the remote compute context, and returned to your R environment.</source>
        </trans-unit><trans-unit id="153" translate="yes" xml:space="preserve">
          <source>View the graph by opening the R graphics device, or by clicking the <bpt id="p1">**</bpt>Plot<ept id="p1">**</ept> window in RStudio.</source>
        </trans-unit><trans-unit id="154" translate="yes" xml:space="preserve">
          <source><bpt id="p1">![</bpt>ROC plot for the model<ept id="p1">](media/rsql-e2e-rocplot.png "|::ref1::|")</ept></source>
        </trans-unit><trans-unit id="155" translate="yes" xml:space="preserve">
          <source>Create the plots in the local compute context using data from SQL Server</source>
        </trans-unit><trans-unit id="156" translate="yes" xml:space="preserve">
          <source>You can verify the compute context is local by running <ph id="ph1">`rxGetComputeContext()`</ph> at the command prompt.</source>
        </trans-unit><trans-unit id="157" translate="yes" xml:space="preserve">
          <source>The return value should be "RxLocalSeq Compute Context".</source>
        </trans-unit><trans-unit id="158" translate="yes" xml:space="preserve">
          <source>For the local compute context, the process is much the same.</source>
        </trans-unit><trans-unit id="159" translate="yes" xml:space="preserve">
          <source>You use the <bpt id="p1">[</bpt>rxImport<ept id="p1">](https://docs.microsoft.com/r-server/r-reference/revoscaler/rximport)</ept> function to bring the specified data into your local R environment.</source>
        </trans-unit><trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Using the data in local memory, you load the <bpt id="p1">**</bpt>ROCR<ept id="p1">**</ept> package, and use the prediction function from that package to create some new predictions.</source>
        </trans-unit><trans-unit id="161" translate="yes" xml:space="preserve">
          <source>Generate a local plot, based on the values stored in the output variable <ph id="ph1">`pred`</ph>.</source>
        </trans-unit><trans-unit id="162" translate="yes" xml:space="preserve">
          <source><bpt id="p1">![</bpt>plotting model performance using R<ept id="p1">](media/rsql-e2e-performanceplot.png "|::ref2::|")</ept></source>
        </trans-unit><trans-unit id="163" translate="yes" xml:space="preserve">
          <source>Your charts might look different from these, depending on how many data points you used.</source>
        </trans-unit><trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Deploy the model</source>
        </trans-unit><trans-unit id="165" translate="yes" xml:space="preserve">
          <source>After you have built a model and ascertained that it is performing well, you probably want to deploy it to a site where users or people in your organization can make use of the model, or perhaps retrain and recalibrate the model on a regular basis.</source>
        </trans-unit><trans-unit id="166" translate="yes" xml:space="preserve">
          <source>This process is sometimes called  <bpt id="p1">*</bpt>operationalizing<ept id="p1">*</ept> a model.</source>
        </trans-unit><trans-unit id="167" translate="yes" xml:space="preserve">
          <source>In SQL Server, operationalization is achieved by embedding R code in a stored procedure.</source>
        </trans-unit><trans-unit id="168" translate="yes" xml:space="preserve">
          <source>Because code resides in the procedure, it can be called from any application that can connect to SQL Server.</source>
        </trans-unit><trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Before you can call the model from an external application, you must save the model to the database used for production.</source>
        </trans-unit><trans-unit id="170" translate="yes" xml:space="preserve">
          <source>Trained models are stored in binary form, in a single column of type <bpt id="p1">**</bpt>varbinary(max)<ept id="p1">**</ept>.</source>
        </trans-unit><trans-unit id="171" translate="yes" xml:space="preserve">
          <source>A typical deployment workflow consists of the following steps:</source>
        </trans-unit><trans-unit id="172" translate="yes" xml:space="preserve">
          <source>Serialize the model into a hexadecimal string</source>
        </trans-unit><trans-unit id="173" translate="yes" xml:space="preserve">
          <source>Transmit the serialized object to the database</source>
        </trans-unit><trans-unit id="174" translate="yes" xml:space="preserve">
          <source>Save the model in a varbinary(max) column</source>
        </trans-unit><trans-unit id="175" translate="yes" xml:space="preserve">
          <source>In this section, learn how to use a stored procedure to persist the model and make it available for predictions.</source>
        </trans-unit><trans-unit id="176" translate="yes" xml:space="preserve">
          <source>The stored procedure used in this section is PersistModel.</source>
        </trans-unit><trans-unit id="177" translate="yes" xml:space="preserve">
          <source>The definition of PersistModel is in <bpt id="p1">[</bpt>Prerequisites<ept id="p1">](#prerequisites)</ept>.</source>
        </trans-unit><trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Switch back to your local R environment if you are not already using it, serialize the model, and save it in a variable.</source>
        </trans-unit><trans-unit id="179" translate="yes" xml:space="preserve">
          <source>Open an ODBC connection using <bpt id="p1">**</bpt>RODBC<ept id="p1">**</ept>.</source>
        </trans-unit><trans-unit id="180" translate="yes" xml:space="preserve">
          <source>You can omit the call to RODBC if you already have the package loaded.</source>
        </trans-unit><trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Call the PersistModel stored procedure on SQL Server to transmite the serialized object to the database and store the binary representation of the model in a column.</source>
        </trans-unit><trans-unit id="182" translate="yes" xml:space="preserve">
          <source>Use Management Studio to verify the model exists.</source>
        </trans-unit><trans-unit id="183" translate="yes" xml:space="preserve">
          <source>In Object Explorer, right-click on the <bpt id="p1">**</bpt>nyc_taxi_models<ept id="p1">**</ept> table and click <bpt id="p2">**</bpt>Select Top 1000 Rows<ept id="p2">**</ept>.</source>
        </trans-unit><trans-unit id="184" translate="yes" xml:space="preserve">
          <source>In Results, you should see a binary representation in the <bpt id="p1">**</bpt>models<ept id="p1">**</ept> column.</source>
        </trans-unit><trans-unit id="185" translate="yes" xml:space="preserve">
          <source>Saving a model to a table requires only an INSERT statement.</source>
        </trans-unit><trans-unit id="186" translate="yes" xml:space="preserve">
          <source>However, it's often easier when wrapped in a stored procedure, such as <bpt id="p1">*</bpt>PersistModel<ept id="p1">*</ept>.</source>
        </trans-unit><trans-unit id="187" translate="yes" xml:space="preserve">
          <source>Next steps</source>
        </trans-unit><trans-unit id="188" translate="yes" xml:space="preserve">
          <source>In the next and final lesson, learn how to perform scoring against the saved model using <ph id="ph1">[!INCLUDE[tsql](../../includes/tsql-md.md)]</ph>.</source>
        </trans-unit><trans-unit id="189" translate="yes" xml:space="preserve">
          <source><bpt id="p1">[</bpt>Deploy the R model and use in SQL<ept id="p1">](walkthrough-deploy-and-use-the-model.md)</ept></source>
        </trans-unit><trans-unit id="190" translate="yes" xml:space="preserve" extradata="ref1">
          <source>ROC plot for the model</source>
        </trans-unit><trans-unit id="191" translate="yes" xml:space="preserve" extradata="ref2">
          <source>plotting model performance using R</source>
        </trans-unit></group></body></file></xliff>